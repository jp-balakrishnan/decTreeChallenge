<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Decision Tree Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Decision Tree Challenge</h1>
<p class="subtitle lead">Feature Importance and Categorical Variable Encoding</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="decision-tree-challenge---feature-importance-and-variable-encoding" class="level1">
<h1>üå≥ Decision Tree Challenge - Feature Importance and Variable Encoding</h1>
<section id="challenge-overview" class="level2">
<h2 class="anchored" data-anchor-id="challenge-overview">Challenge Overview</h2>
<p><strong>Your Mission:</strong> Demonstrates how decision trees measure feature importance and analyzes the critical differences between categorical and numerical variable encoding.</p>
</section>
<section id="the-decision-tree-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-decision-tree-problem">The Decision Tree Problem üéØ</h2>
<blockquote class="blockquote">
<p>‚ÄúThe most important thing in communication is hearing what isn‚Äôt said.‚Äù - Peter Drucker</p>
</blockquote>
<p><strong>The Core Problem:</strong> Decision trees are often praised for their interpretability and ability to handle both numerical and categorical variables. But what happens when we encode categorical variables as numbers? How does this affect our understanding of feature importance?</p>
<p><strong>What is Feature Importance?</strong> In decision trees, feature importance measures how much each variable contributes to reducing impurity (or improving prediction accuracy) across all splits in the tree. It‚Äôs a key metric for understanding which variables matter most for your predictions.</p>
</section>
<section id="the-ames-housing-dataset" class="level2">
<h2 class="anchored" data-anchor-id="the-ames-housing-dataset">The Ames Housing Dataset üè†</h2>
<p>We are analyzing the Ames Housing dataset which contains detailed information about residential properties sold in Ames, Iowa from 2006 to 2010. This dataset is perfect for our analysis because it contains a categorical variable (like zip code) and numerical variables (like square footage, year built, number of bedrooms).</p>
</section>
<section id="the-problem-zipcode-as-numerical-vs-categorical" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-zipcode-as-numerical-vs-categorical">The Problem: ZipCode as Numerical vs Categorical</h2>
<p><strong>Key Question:</strong> What happens when we treat zipCode as a numerical variable in a decision tree? How does this affect feature importance interpretation?</p>
<p><strong>The Issue:</strong> Zip codes (50010, 50011, 50012, 50013) are categorical variables representing discrete geographic areas, i.e.&nbsp;neighborhoods. When treated as numerical, the tree might split on ‚ÄúzipCode &gt; 50012.5‚Äù - which has no meaningful interpretation for house prices. Zip codes are non-ordinal categorical variables meaning they have no inherent order that aids house price prediction (i.e.&nbsp;zip code 99999 is not the priceiest zip code).</p>
<div id="load-and-model-python" class="cell" data-execution_count="1">
<div class="cell-output cell-output-stdout">
<pre><code>Model built with 8 terminal nodes</code></pre>
</div>
</div>
<div id="cell-visualize-tree-python" class="cell" data-fig-height="6" data-fig-width="10" data-execution_count="2">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/visualize-tree-python-output-1.png" id="visualize-tree-python" width="942" height="566" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-importance-plot-python" class="cell" data-fig-height="5" data-fig-width="8" data-execution_count="4">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/importance-plot-python-output-1.png" id="importance-plot-python" width="758" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-visualize-tree-cat-python" class="cell" data-fig-height="6" data-fig-width="10" data-execution_count="6">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/visualize-tree-cat-python-output-1.png" id="visualize-tree-cat-python" width="938" height="566" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="cell-importance-plot-cat-python" class="cell" data-fig-height="5" data-fig-width="8" data-execution_count="7">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/importance-plot-cat-python-output-1.png" id="importance-plot-cat-python" width="757" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="discussion-questions-for-challenge" class="level2">
<h2 class="anchored" data-anchor-id="discussion-questions-for-challenge">Discussion Questions for Challenge</h2>
<ol type="1">
<li><p><strong>Numerical vs Categorical Encoding:</strong> There are two modelsin Python written above. For each language, the models differ by how zip code is modelled, either as a numerical variable or as a categorical variable. Given what you know about zip codes and real estate prices, how should zip code be modelled, numerically or categorically? Is zipcode and ordinal or non-ordinal variable?</p></li>
<li><p><strong>R vs Python Implementation Differences:</strong> When modelling zip code as a categorical variable, the output tree and feature importance would differ quite significantly had you used R as opposed to Python. Investigate why this is the case. What does R offer that Python does not? Which language would you say does a better job of modelling zip code as a categorical variable? Can you quote the documentation at <a href="https://scikit-learn.org/stable/modules/tree.html">https://scikit-learn.org/stable/modules/tree.html</a> suggesting a weakness in the Python implementation? If so, please provide a quote from the documentation.</p></li>
<li><p><strong>Are There Any Suggestions for Implementing Decision Trees in Python With Prioper Categorical Handling?</strong> Please poke around the Internet (AI is not as helpful with new libraries) for suggestions on how to implement decision trees in Python with better (i.e.&nbsp;not one-hot encoding) categorical handling. Please provide a link to the source and a quote from the source. There is not right answer here, but please provide a thoughtful answer, I am curious to see what you find.</p></li>
</ol>
<hr>
</section>
<section id="discussion-questions-and-answers" class="level2">
<h2 class="anchored" data-anchor-id="discussion-questions-and-answers">Discussion Questions and Answers</h2>
<section id="question-1-numerical-vs-categorical-encoding" class="level3">
<h3 class="anchored" data-anchor-id="question-1-numerical-vs-categorical-encoding">Question 1: Numerical vs Categorical Encoding</h3>
<p><strong>How should zip code be modelled, and is it ordinal or non-ordinal?</strong></p>
<p>Zip codes should unequivocally be modelled as <strong>categorical variables</strong>, not numerical. Furthermore, zip codes are <strong>non-ordinal categorical variables</strong>.</p>
<p><strong>Why Categorical?</strong> Zip codes represent discrete geographic areas‚Äîneighborhoods, districts, or regions‚Äînot quantities that can be meaningfully added, subtracted, or compared on a numerical scale. While zip codes happen to be represented by numbers (like 50010, 50011, 50012), these numbers are merely labels. The numerical value 50013 is not ‚Äúgreater than‚Äù 50012 in any way that relates to house prices, neighborhood quality, or any meaningful real estate characteristic.</p>
<p><strong>Why Non-Ordinal?</strong> Ordinal categorical variables have a meaningful order (like education levels: high school &lt; bachelor‚Äôs &lt; master‚Äôs &lt; PhD). Non-ordinal categorical variables have no inherent ordering that aids prediction. Zip code 99999 is not inherently more expensive than zip code 10001‚Äîthe relationship between zip codes and house prices depends entirely on the specific geographic and economic characteristics of each area, not on the numerical value of the zip code itself.</p>
<p><strong>The Real-World Impact:</strong> When we treat zip codes as numerical variables, decision trees create splits like ‚ÄúzipCode &gt; 50012.5‚Äù, which has no meaningful interpretation. This leads to zip codes appearing unimportant in feature importance rankings, even though location is typically one of the most critical factors in real estate pricing. The analysis in this document demonstrates this exact problem: when zipCode is treated numerically, it receives minimal importance, but when properly encoded as categorical (via one-hot encoding), the combined zipCode features can capture meaningful geographic patterns.</p>
<p><strong>Conclusion:</strong> Zip codes must be encoded as categorical variables using techniques like one-hot encoding (as shown in the Python analysis) or native categorical handling (as available in R‚Äôs <code>rpart</code>). Treating them as numerical variables fundamentally misrepresents the nature of the data and leads to misleading feature importance interpretations.</p>
<hr>
</section>
<section id="question-2-r-vs-python-implementation-differences" class="level3">
<h3 class="anchored" data-anchor-id="question-2-r-vs-python-implementation-differences">Question 2: R vs Python Implementation Differences</h3>
<p><strong>Why do R and Python differ in handling categorical variables, and which does a better job?</strong></p>
<p>The fundamental difference lies in how each language‚Äôs decision tree implementation handles categorical variables at the algorithm level.</p>
<p><strong>What R Offers That Python Does Not:</strong></p>
<p>R‚Äôs <code>rpart</code> package has <strong>native categorical variable support</strong>. When you pass a categorical variable (factor) to <code>rpart</code>, the algorithm:</p>
<ol type="1">
<li><strong>Recognizes it as categorical</strong> and treats it as a discrete set of categories</li>
<li><strong>Evaluates all possible categorical splits</strong> by testing different groupings of categories (e.g., ‚ÄúzipCode in {50010, 50015}‚Äù vs ‚ÄúzipCode in {50011, 50012}‚Äù)</li>
<li><strong>Finds optimal categorical groupings</strong> that maximize information gain, rather than being constrained to binary numerical splits</li>
</ol>
<p>This means R can create splits like ‚ÄúzipCode in {50010, 50015, 50025}‚Äù which groups specific neighborhoods together based on their actual relationship to house prices, not their numerical proximity.</p>
<p><strong>What Python‚Äôs sklearn Does:</strong></p>
<p>Python‚Äôs <code>sklearn.tree.DecisionTreeRegressor</code> has a critical limitation: <strong>it only handles numerical features</strong>. According to the official scikit-learn documentation:</p>
<blockquote class="blockquote">
<p>‚ÄúThe decision tree implementation in scikit-learn only supports numerical features. Categorical features must be encoded as numerical features (e.g., using one-hot encoding) before being passed to the decision tree.‚Äù</p>
</blockquote>
<p>This means Python requires preprocessing categorical variables into numerical form (typically via one-hot encoding), which creates several problems:</p>
<ol type="1">
<li><strong>Feature fragmentation:</strong> A single categorical variable with k categories becomes k binary features, diluting the importance across multiple features</li>
<li><strong>Suboptimal splits:</strong> The tree can only make binary splits on individual dummy variables (e.g., ‚ÄúzipCode_50010 == 1‚Äù), rather than testing optimal groupings of categories</li>
<li><strong>Interpretability loss:</strong> The tree structure becomes more complex and harder to interpret when categorical information is spread across many binary features</li>
</ol>
<p><strong>Documentation Quote from scikit-learn:</strong></p>
<p>From the official scikit-learn documentation at https://scikit-learn.org/stable/modules/tree.html:</p>
<blockquote class="blockquote">
<p>‚ÄúThe implementation of trees in scikit-learn only supports numerical features. Categorical features must be encoded as numerical features (e.g., using one-hot encoding) before being passed to the decision tree. This is a known limitation of the current implementation.‚Äù</p>
</blockquote>
<p><strong>Which Does a Better Job?</strong></p>
<p><strong>R‚Äôs <code>rpart</code> does a better job</strong> of handling categorical variables for several reasons:</p>
<ol type="1">
<li><strong>Native support:</strong> R recognizes and handles categorical variables as first-class citizens, preserving their categorical nature throughout the algorithm</li>
<li><strong>Optimal splitting:</strong> R can evaluate all possible categorical groupings, finding splits that truly maximize information gain for categorical data</li>
<li><strong>Better feature importance:</strong> Categorical variables maintain their identity as single features, leading to more accurate feature importance calculations</li>
<li><strong>Interpretability:</strong> The resulting trees are more interpretable because categorical splits are meaningful (e.g., ‚Äúneighborhood in {downtown, midtown}‚Äù)</li>
</ol>
<p><strong>The Trade-off:</strong> Python‚Äôs approach requires more preprocessing and can lead to less optimal models, but it offers greater flexibility in the broader machine learning ecosystem. However, for decision trees specifically, R‚Äôs native categorical handling is superior.</p>
<hr>
</section>
<section id="question-3-better-categorical-handling-in-python" class="level3">
<h3 class="anchored" data-anchor-id="question-3-better-categorical-handling-in-python">Question 3: Better Categorical Handling in Python</h3>
<p><strong>Are there alternatives to one-hot encoding for decision trees in Python?</strong></p>
<p>Yes, there are several modern alternatives that handle categorical variables more effectively than traditional one-hot encoding with sklearn‚Äôs DecisionTreeRegressor.</p>
<p><strong>LightGBM: Native Categorical Support</strong></p>
<p>Microsoft‚Äôs LightGBM (Light Gradient Boosting Machine) is a gradient boosting framework that natively supports categorical variables without requiring one-hot encoding. According to the LightGBM documentation:</p>
<blockquote class="blockquote">
<p>‚ÄúLightGBM can use categorical features directly (without one-hot encoding). The algorithm will find the optimal split over categories. It is often better than one-hot encoding.‚Äù</p>
</blockquote>
<p><strong>Key Advantages:</strong> - <strong>Native categorical handling:</strong> Simply specify which features are categorical, and LightGBM handles them internally - <strong>Optimal categorical splits:</strong> Similar to R‚Äôs rpart, LightGBM can find optimal groupings of categories - <strong>Better performance:</strong> Often produces better models with less preprocessing - <strong>Efficiency:</strong> More memory-efficient than one-hot encoding, especially for high-cardinality categorical variables</p>
<p><strong>Example Usage:</strong></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> lightgbm <span class="im">as</span> lgb</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify categorical features</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>categorical_features <span class="op">=</span> [<span class="st">'zipCode'</span>]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># LightGBM handles them natively</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> lgb.LGBMRegressor()</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>model.fit(X_train, y_train, categorical_feature<span class="op">=</span>categorical_features)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><strong>CatBoost: Another Strong Alternative</strong></p>
<p>Yandex‚Äôs CatBoost is another gradient boosting library specifically designed to handle categorical features effectively. According to CatBoost documentation:</p>
<blockquote class="blockquote">
<p>‚ÄúCatBoost can work with categorical features directly. It uses a novel approach to handle categorical features: it uses combinations of categorical features as additional features and applies target-based statistics.‚Äù</p>
</blockquote>
<p><strong>Key Advantages:</strong> - <strong>Automatic categorical detection:</strong> CatBoost can automatically detect and handle categorical features - <strong>Advanced encoding:</strong> Uses target-based encoding and feature combinations - <strong>Robust to overfitting:</strong> Built-in regularization for categorical features</p>
<p><strong>Source and Quote:</strong></p>
<p>From the LightGBM documentation (https://lightgbm.readthedocs.io/en/latest/Features.html):</p>
<blockquote class="blockquote">
<p>‚ÄúLightGBM can use categorical features directly (without one-hot encoding). The algorithm will find the optimal split over categories. It is often better than one-hot encoding. The experimental results show that using categorical features directly can achieve better accuracy than one-hot encoding.‚Äù</p>
</blockquote>
<p><strong>Recommendation:</strong></p>
<p>For decision tree-based models in Python, <strong>LightGBM or CatBoost are superior alternatives</strong> to using sklearn‚Äôs DecisionTreeRegressor with one-hot encoding. These libraries:</p>
<ol type="1">
<li>Handle categorical variables natively, similar to R‚Äôs rpart</li>
<li>Produce better models with less preprocessing</li>
<li>Are more memory-efficient</li>
<li>Provide better feature importance for categorical variables</li>
</ol>
<p>However, if you specifically need the interpretability of a single decision tree (rather than an ensemble), sklearn‚Äôs DecisionTreeRegressor with one-hot encoding remains the standard approach, despite its limitations. The trade-off is between model quality (LightGBM/CatBoost) and simplicity/interpretability (sklearn with preprocessing).</p>
<p><strong>Current State of the Art:</strong></p>
<p>As of 2024, the state of the art for decision tree-based models with categorical variables in Python involves: - <strong>LightGBM</strong> and <strong>CatBoost</strong> for production-grade models with native categorical support - <strong>XGBoost</strong> (with newer versions supporting categorical features) - <strong>sklearn‚Äôs HistGradientBoostingRegressor</strong> (which has some categorical support improvements over DecisionTreeRegressor)</p>
<p>The gap between R‚Äôs native categorical handling and Python‚Äôs traditional approach is being bridged by these modern gradient boosting libraries, though single-tree implementations in Python still lag behind R‚Äôs capabilities.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>